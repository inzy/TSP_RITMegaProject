"""
Purpose - Comparison : Compared the outputs of the Ant Colony Optimization (ACO) and Non-dominated Sorting Genetic Algorithm II (NSGA-II) for the multi-objective Traveling Salesman Problem (TSP), We have examined key factors such as the total distance, total cost, diversity of solutions, and convergence to the Pareto front.


Individually run:
Steps for Comparison:
1.Run Both Algorithms: Execute the ACO and NSGA-II algorithms using the same set of nodes to ensure consistency in the comparison.
2.Record Results: Capture the best solutions found by both algorithms, including their total distance, total cost, and tour sequence.
3.Analyze Pareto Fronts: Compare the Pareto fronts generated by NSGA-II and the single solution from ACO.
4.Diversity and Convergence: Evaluate the diversity and convergence of the solutions.

Run and Compare Outputs:
1.Run ACO:
a.Capture the best tour, total distance, and total cost.
b.Plot the solution.
2.Run NSGA-II:
a.Capture the Pareto front (multiple solutions).
b.Plot the Pareto front showing trade-offs between distance and cost.


Analysis:
1.Best Solution Comparison:
a.Compare the best solution found by ACO with the best solution in the Pareto front of NSGA-II.
b.Check if the ACO solution is part of the Pareto front.
2.Diversity and Convergence:
a.Assess the diversity of solutions provided by NSGA-II.
b.Evaluate how well NSGA-II explores the trade-offs between distance and cost.

Insights:
1.Performance:
a.ACO might find a single optimal solution quickly.
b.NSGA-II provides a range of solutions, showing the trade-offs between objectives.
2.Optimization Objectives:
a.ACO optimizes a single objective (distance) while providing a cost.
b.NSGA-II simultaneously optimizes both distance and cost, offering a diverse set of optimal solutions.
3.Algorithm Choice:
a.Use ACO for fast, single-objective optimization.
b.Use NSGA-II for comprehensive multi-objective optimization, exploring trade-offs and diverse solutions.

Note - This comparative analysis provides a deeper understanding of both algorithms' capabilities, performance, and suitable applications in optimizing TSP with multiple objectives.


Combined run
1.Steps to Run and Compare Outputs:
a.Run the combined code to execute both ACO and NSGA-II algorithms.
b.Capture and print the best tour, total distance, and total cost from both algorithms.
c.Plot the solutions for visualization.
d.Analyze and compare the performance, diversity, and convergence of the solutions obtained by both algorithms.
2.Insights:
a.Performance: ACO quickly finds a single optimal solution, while NSGA-II explores multiple trade-off solutions.
b.Optimization Objectives: ACO optimizes distance and calculates cost, whereas NSGA-II simultaneously optimizes both objectives.
c.Algorithm Choice: ACO is suitable for fast single-objective optimization, while NSGA-II provides a comprehensive multi-objective optimization with diverse solutions.

"""

import math
import random
import matplotlib.pyplot as plt


class SolveTSPUsingACO:
    class Edge:
        def __init__(self, a, b, weight, initial_pheromone):
            self.a = a
            self.b = b
            self.weight = weight
            self.pheromone = initial_pheromone

    class Ant:
        def __init__(self, alpha, beta, num_nodes, edges):
            self.alpha = alpha
            self.beta = beta
            self.num_nodes = num_nodes
            self.edges = edges
            self.tour = None
            self.distance = 0.0
            self.cost = 0.0

        def _select_node(self):
            roulette_wheel = 0.0
            unvisited_nodes = [node for node in range(self.num_nodes) if node not in self.tour]
            heuristic_total = 0.0
            for unvisited_node in unvisited_nodes:
                heuristic_total += self.edges[self.tour[-1]][unvisited_node].weight
            for unvisited_node in unvisited_nodes:
                roulette_wheel += pow(self.edges[self.tour[-1]][unvisited_node].pheromone, self.alpha) * \
                                  pow((heuristic_total / self.edges[self.tour[-1]][unvisited_node].weight), self.beta)
            random_value = random.uniform(0.0, roulette_wheel)
            wheel_position = 0.0
            for unvisited_node in unvisited_nodes:
                wheel_position += pow(self.edges[self.tour[-1]][unvisited_node].pheromone, self.alpha) * \
                                  pow((heuristic_total / self.edges[self.tour[-1]][unvisited_node].weight), self.beta)
                if wheel_position >= random_value:
                    return unvisited_node

        def find_tour(self):
            self.tour = [random.randint(0, self.num_nodes - 1)]
            while len(self.tour) < self.num_nodes:
                self.tour.append(self._select_node())
            self.distance = self.get_distance()
            self.cost = self.get_cost()
            return self.tour

        def get_distance(self):
            distance = 0.0
            for i in range(self.num_nodes):
                distance += self.edges[self.tour[i]][self.tour[(i + 1) % self.num_nodes]].weight
            return distance

        def get_cost(self):
            return sum([random.uniform(1, 10) for _ in range(self.num_nodes)])  # Random cost for demonstration

    def __init__(self, mode='ACS', colony_size=10, elitist_weight=1.0, min_scaling_factor=0.001, alpha=1.0, beta=3.0,
                 rho=0.1, pheromone_deposit_weight=1.0, initial_pheromone=1.0, steps=100, nodes=None, labels=None):
        self.mode = mode
        self.colony_size = colony_size
        self.elitist_weight = elitist_weight
        self.min_scaling_factor = min_scaling_factor
        self.rho = rho
        self.pheromone_deposit_weight = pheromone_deposit_weight
        self.steps = steps
        self.num_nodes = len(nodes)
        self.nodes = nodes
        if labels is not None:
            self.labels = labels
        else:
            self.labels = range(1, self.num_nodes + 1)
        self.edges = [[None] * self.num_nodes for _ in range(self.num_nodes)]
        for i in range(self.num_nodes):
            for j in range(i + 1, self.num_nodes):
                self.edges[i][j] = self.edges[j][i] = self.Edge(i, j, math.sqrt(
                    pow(self.nodes[i][0] - self.nodes[j][0], 2.0) + pow(self.nodes[i][1] - self.nodes[j][1], 2.0)),
                                                                initial_pheromone)
        self.ants = [self.Ant(alpha, beta, self.num_nodes, self.edges) for _ in range(self.colony_size)]
        self.global_best_tour = None
        self.global_best_distance = float("inf")
        self.global_best_cost = float("inf")

    def _add_pheromone(self, tour, distance, weight=1.0):
        pheromone_to_add = self.pheromone_deposit_weight / distance
        for i in range(self.num_nodes):
            self.edges[tour[i]][tour[(i + 1) % self.num_nodes]].pheromone += weight * pheromone_to_add

    def _acs(self):
        for step in range(self.steps):
            for ant in self.ants:
                self._add_pheromone(ant.find_tour(), ant.get_distance())
                if ant.distance < self.global_best_distance:
                    self.global_best_tour = ant.tour
                    self.global_best_distance = ant.distance
                    self.global_best_cost = ant.cost
            for i in range(self.num_nodes):
                for j in range(i + 1, self.num_nodes):
                    self.edges[i][j].pheromone *= (1.0 - self.rho)

    def run(self):
        print('Started : {0}'.format(self.mode))
        if self.mode == 'ACS':
            self._acs()
        print('Ended : {0}'.format(self.mode))
        print('Best Tour : <- {0} ->'.format(' - '.join(str(self.labels[i]) for i in self.global_best_tour)))
        print('Total distance travelled to complete the tour : {0}'.format(round(self.global_best_distance, 2)))
        print('Total cost to complete the tour : {0}\n'.format(round(self.global_best_cost, 2)))

    def plot(self, line_width=1, point_radius=math.sqrt(2.0), annotation_size=8, dpi=120, save=True, name=None):
        x = [self.nodes[i][0] for i in self.global_best_tour]
        x.append(x[0])
        y = [self.nodes[i][1] for i in self.global_best_tour]
        y.append(y[0])
        plt.plot(x, y, linewidth=line_width)
        plt.scatter(x, y, s=math.pi * (point_radius ** 2.0))
        plt.title(self.mode)
        for i in self.global_best_tour:
            plt.annotate(self.labels[i], self.nodes[i], size=annotation_size)
        if save:
            if name is None:
                name = '{0}.png'.format(self.mode)
            plt.savefig(name, dpi=dpi)
        plt.show()
        plt.gcf().clear()


class SolveTSPUsingNSGAII:
    class Individual:
        def __init__(self, tour, nodes):
            self.tour = tour
            self.nodes = nodes
            self.distance = self.calculate_distance()
            self.cost = self.calculate_cost()
            self.rank = 0
            self.crowding_distance = 0

        def calculate_distance(self):
            distance = 0.0
            for i in range(len(self.tour)):
                distance += math.sqrt(
                    pow(self.nodes[self.tour[i]][0] - self.nodes[self.tour[(i + 1) % len(self.tour)]][0], 2.0) +
                    pow(self.nodes[self.tour[i]][1] - self.nodes[self.tour[(i + 1) % len(self.tour)]][1], 2.0))
            return distance

        def calculate_cost(self):
            return sum([random.uniform(1, 10) for _ in range(len(self.tour))])  # Random cost for demonstration

    def __init__(self, population_size=100, generations=50, nodes=None):
        self.population_size = population_size
        self.generations = generations
        self.nodes = nodes
        self.population = self.initialize_population()
        self.fronts = []

    def initialize_population(self):
        population = []
        for _ in range(self.population_size):
            tour = random.sample(range(len(self.nodes)), len(self.nodes))
            population.append(self.Individual(tour, self.nodes))
        return population

    def non_dominated_sorting(self):
        fronts = [[]]
        for p in self.population:
            p.dominated_solutions = []
            p.domination_count = 0
            for q in self.population:
                if self.dominates(p, q):
                    p.dominated_solutions.append(q)
                elif self.dominates(q, p):
                    p.domination_count += 1
            if p.domination_count == 0:
                p.rank = 0
                fronts[0].append(p)
        i = 0
        while len(fronts[i]) > 0:
            next_front = []
            for p in fronts[i]:
                for q in p.dominated_solutions:
                    q.domination_count -= 1
                    if q.domination_count == 0:
                        q.rank = i + 1
                        next_front.append(q)
            i += 1
            fronts.append(next_front)
        return fronts[:-1]

    def dominates(self, p, q):
        return (p.distance < q.distance and p.cost <= q.cost) or (p.distance <= q.distance and p.cost < q.cost)

    def calculate_crowding_distance(self, front):
        if len(front) > 0:
            for individual in front:
                individual.crowding_distance = 0
            for m in range(2):
                front.sort(key=lambda x: x.distance if m == 0 else x.cost)
                front[0].crowding_distance = float('inf')
                front[-1].crowding_distance = float('inf')
                for i in range(1, len(front) - 1):
                    front[i].crowding_distance += (front[i + 1].distance - front[i - 1].distance) / (
                            max(front, key=lambda x: x.distance).distance - min(front, key=lambda x: x.distance).distance) if m == 0 else \
                        (front[i + 1].cost - front[i - 1].cost) / (max(front, key=lambda x: x.cost).cost - min(front, key=lambda x: x.cost).cost)

    def selection(self):
        new_population = []
        for front in self.fronts:
            self.calculate_crowding_distance(front)
            front.sort(key=lambda x: (x.rank, -x.crowding_distance))
            new_population.extend(front)
            if len(new_population) >= self.population_size:
                break
        return new_population[:self.population_size]

    def crossover(self, parent1, parent2):
        cut = random.randint(0, len(parent1.tour) - 1)
        child1_tour = parent1.tour[:cut] + [gene for gene in parent2.tour if gene not in parent1.tour[:cut]]
        child2_tour = parent2.tour[:cut] + [gene for gene in parent1.tour if gene not in parent2.tour[:cut]]
        return self.Individual(child1_tour, self.nodes), self.Individual(child2_tour, self.nodes)

    def mutate(self, individual):
        idx1, idx2 = random.sample(range(len(individual.tour)), 2)
        individual.tour[idx1], individual.tour[idx2] = individual.tour[idx2], individual.tour[idx1]
        individual.distance = individual.calculate_distance()
        individual.cost = individual.calculate_cost()

    def evolve(self):
        new_population = []
        while len(new_population) < self.population_size:
            parent1, parent2 = random.sample(self.population, 2)
            child1, child2 = self.crossover(parent1, parent2)
            if random.random() < 0.1:
                self.mutate(child1)
            if random.random() < 0.1:
                self.mutate(child2)
            new_population.extend([child1, child2])
        self.population = new_population

    def run(self):
        for generation in range(self.generations):
            print(f'Generation {generation + 1}/{self.generations}')
            self.fronts = self.non_dominated_sorting()
            self.population = self.selection()
            self.evolve()
        print('Finished Optimization')
        for front in self.fronts[0]:
            print(f'Distance: {front.distance}, Cost: {front.cost}, Tour: {front.tour}')

    def plot(self):
        plt.figure(figsize=(10, 6))
        for front in self.fronts:
            distances = [ind.distance for ind in front]
            costs = [ind.cost for ind in front]
            plt.scatter(distances, costs)
        plt.xlabel('Total Distance')
        plt.ylabel('Total Cost')
        plt.title('Pareto Front')
        plt.show()


if __name__ == '__main__':
    # Nodes: List of coordinates
    _nodes = [(random.uniform(-400, 400), random.uniform(-400, 400)) for _ in range(15)]

    # Solve TSP using ACO
    aco = SolveTSPUsingACO(mode='ACS', colony_size=50, steps=100, nodes=_nodes)
    aco.run()
    aco.plot()

    # Solve TSP using NSGA-II
    nsga_ii = SolveTSPUsingNSGAII(population_size=100, generations=50, nodes=_nodes)
    nsga_ii.run()
    nsga_ii.plot()

    # Comparison and Insights
    print("Comparison of ACO and NSGA-II:")
    print(f"ACO - Best Distance: {aco.global_best_distance}, Best Cost: {aco.global_best_cost}")
    nsga_best_distance = min(ind.distance for ind in nsga_ii.fronts[0])
    nsga_best_cost = min(ind.cost for ind in nsga_ii.fronts[0])
    print(f"NSGA-II - Best Distance: {nsga_best_distance}, Best Cost: {nsga_best_cost}")

    if any(aco.global_best_distance == ind.distance and aco.global_best_cost == ind.cost for ind in nsga_ii.fronts[0]):
        print("The ACO solution is part of the NSGA-II Pareto front.")
    else:
        print("The ACO solution is not part of the NSGA-II Pareto front.")
