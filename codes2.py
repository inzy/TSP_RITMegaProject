# -*- coding: utf-8 -*-
"""MO_TSP_AMTPG_Jaya .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aTHVUVwX31MuS_IUtKPSkDJPUSeFWV27
"""

import numpy as np
import matplotlib.pyplot as plt
import time

# Initialize population
def initialize_population(num_cities, population_size):
    return [np.random.permutation(num_cities) for _ in range(population_size)]

# Calculate total distance for a route
def calculate_total_distance(route, distance_matrix):
    return sum(distance_matrix[route[i], route[i + 1]] for i in range(len(route) - 1)) + distance_matrix[route[-1], route[0]]

# Calculate total time for a route (for multi-objective, replace with your own logic)
def calculate_total_time(route, time_matrix):
    return sum(time_matrix[route[i], route[i + 1]] for i in range(len(route) - 1)) + time_matrix[route[-1], route[0]]

# Evaluate the population fitness (considering multiple objectives)
def evaluate_population(population, distance_matrix, time_matrix):
    return [(calculate_total_distance(route, distance_matrix), calculate_total_time(route, time_matrix)) for route in population]

# Calculate crowding distance for each individual in the population
def calculate_crowding_distance(fitness):
    distance = np.zeros(len(fitness))
    sorted_fitness = sorted(fitness, key=lambda x: x[0])
    distance[0] = distance[-1] = float('inf')  # Ensure boundary solutions are always selected

    # Calculate crowding distance for each individual
    for i in range(1, len(fitness) - 1):
        distance[i] = (sorted_fitness[i + 1][0] - sorted_fitness[i - 1][0]) + (sorted_fitness[i + 1][1] - sorted_fitness[i - 1][1])

    return distance

# Update team solutions
def update_solution(team, best_solution, worst_solution, distance_matrix, time_matrix):
    new_population = []
    for route in team:
        new_route = route.copy()
        num_cities = len(route)

        for i in range(num_cities):
            if np.random.rand() < 0.5:
                new_route[i] = best_solution[i]
            elif np.random.rand() < 0.5:
                new_route[i] = worst_solution[i]

        # Ensure feasibility using swap operation
        for i in range(num_cities):
            if np.count_nonzero(new_route == new_route[i]) > 1:
                missing_cities = list(set(range(num_cities)) - set(new_route))
                new_route[i] = missing_cities[0]

        new_population.append(new_route)

    return new_population

# Split population into teams
def split_into_teams(population, num_teams):
    return np.array_split(population, num_teams)

# Generate random city coordinates
def generate_random_coordinates(num_cities, x_range=(0, 10), y_range=(0, 10)):
    return [(np.random.uniform(*x_range), np.random.uniform(*y_range)) for _ in range(num_cities)]

# Find the global best and worst solutions using Pareto dominance
def pareto_dominance(fitness1, fitness2):
    # Returns True if fitness1 dominates fitness2
    return (fitness1[0] <= fitness2[0] and fitness1[1] <= fitness2[1]) and (fitness1[0] < fitness2[0] or fitness1[1] < fitness2[1])

# AMTPG Jaya Algorithm with dynamic team adjustments and convergence
def amtpj_jaya_tsp(distance_matrix, time_matrix, num_teams=3, population_size=50, iterations=50, convergence_threshold=5):
    num_cities = len(distance_matrix)
    population = initialize_population(num_cities, population_size)
    teams = split_into_teams(population, num_teams)

    global_best_solution = None
    global_best_fitness = (float('inf'), float('inf'))  # (distance, time)

    all_best_routes = []  # Store best routes for each iteration
    all_best_distances = []  # Store best distances for each iteration
    all_best_times = []  # Store best times for each iteration

    stagnant_iterations = 0  # Count of iterations without improvement

    # Define evaluate_population function to calculate fitness for each route in a population
    def evaluate_population(population, distance_matrix, time_matrix):
        return [(calculate_total_distance(route, distance_matrix), calculate_total_time(route, time_matrix)) for route in population]

    for iteration in range(iterations):
        start_time = time.time()

        # Evaluate teams
        team_fitness = [evaluate_population(team, distance_matrix, time_matrix) for team in teams]

        # Find global best and worst solutions using Pareto dominance
        global_best_fitness_iteration = None
        global_best_solution = None

        for team in teams:
            for route in team:
                route_fitness = (calculate_total_distance(route, distance_matrix), calculate_total_time(route, time_matrix))

                if global_best_fitness_iteration is None or pareto_dominance(route_fitness, global_best_fitness_iteration):
                    global_best_solution = route
                    global_best_fitness_iteration = route_fitness

        # Update global best using Pareto dominance (considering both distance and time)
        if global_best_fitness_iteration is not None and (global_best_fitness_iteration[0] < global_best_fitness[0] or global_best_fitness_iteration[1] < global_best_fitness[1]):
            global_best_solution = global_best_solution
            global_best_fitness = global_best_fitness_iteration
            stagnant_iterations = 0  # Reset stagnant iterations
        else:
            stagnant_iterations += 1

        # Save the best route and fitness for this iteration
        all_best_routes.append(global_best_solution)
        all_best_distances.append(global_best_fitness_iteration[0])
        all_best_times.append(global_best_fitness_iteration[1])

        # Dynamic team adjustments: Replace underperforming teams
        team_qualities = [np.mean([fitness[0] for fitness in team_fitness]) for team_fitness in team_fitness]
        worst_team_index = np.argmax(team_qualities)  # Team with highest average fitness (worst)
        teams[worst_team_index] = initialize_population(num_cities, len(teams[worst_team_index]))

        # Update each team's solutions
        for i, team in enumerate(teams):
            teams[i] = update_solution(team, global_best_solution, teams[i][0], distance_matrix, time_matrix)

        end_time = time.time()

        # Print the path and distance for this iteration
        print(f"Iteration {iteration + 1}:")
        print(f"Global Best Path: {global_best_solution}")
        print(f"Global Best Distance: {global_best_fitness_iteration[0]}")
        print(f"Global Best Time: {global_best_fitness_iteration[1]}")
        print(f"Time Taken: {end_time - start_time:.4f} seconds\n")

        # Check for convergence
        if stagnant_iterations >= convergence_threshold:
            print(f"Convergence reached after {iteration + 1} iterations.")
            break

    return global_best_solution, global_best_fitness, all_best_routes, all_best_distances, all_best_times

# Plot a route
def plot_route(route, cities_coordinates, title):
    # Extract the coordinates of the cities based on the route
    route_coordinates = [cities_coordinates[i] for i in route]

    # Add the starting city at the end of the route to close the loop
    route_coordinates.append(cities_coordinates[route[0]])

    # Unzip the list of coordinates into x and y lists
    x, y = zip(*route_coordinates)

    plt.figure(figsize=(10, 6))
    plt.plot(x, y, 'o-', label="Route")
    plt.scatter(x[0], y[0], color='red', label='Start/End', s=100)
    plt.title(title)
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.legend()
    plt.show()

# Read distance matrix from a file
def read_distance_matrix(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()
    distance_matrix = []
    for line in lines:
        row = [float(value) for value in line.strip().split()]
        distance_matrix.append(row)
    size = len(distance_matrix)
    full_matrix = np.zeros((size, size))
    for i in range(size):
        for j in range(len(distance_matrix[i])):
            full_matrix[i, j] = distance_matrix[i][j]
            full_matrix[j, i] = distance_matrix[i][j]
    return full_matrix

# Example Usage
file_path = 'cities.txt'
distance_matrix = read_distance_matrix(file_path)
time_matrix = read_distance_matrix(file_path)  # Assuming time matrix is the same, modify if different

# Generate random city coordinates (just an example)
cities_coordinates = generate_random_coordinates(len(distance_matrix))

# Find the initial best route before optimization
initial_population = initialize_population(len(distance_matrix), 50)
initial_best_route = min(initial_population, key=lambda route: calculate_total_distance(route, distance_matrix))

# Calculate the distance and time for the initial best route
initial_best_distance = calculate_total_distance(initial_best_route, distance_matrix)
initial_best_time = calculate_total_time(initial_best_route, time_matrix)

# Print the initial best route, distance, and time before optimization
print("Initial Best Route Before Optimization:")
print("Route:", initial_best_route)
print("Distance:", initial_best_distance)
print("Time:", initial_best_time)

# Solve the TSP using the AMTPG Jaya Algorithm
best_route, best_fitness, all_best_routes, all_best_distances, all_best_times = amtpj_jaya_tsp(distance_matrix, time_matrix, num_teams=3, iterations=50, convergence_threshold=5)

# Print final results after optimization
print("\nBest Route After Optimization:")
print("Route:", best_route)
print("Best Distance:", best_fitness[0])
print("Best Time:", best_fitness[1])

# Plot the Best Route before Optimization
plot_route(initial_best_route, cities_coordinates, "Best Route Before Optimization")

# Plot the Best Route after Optimization
plot_route(best_route, cities_coordinates, "Best Route After Optimization")